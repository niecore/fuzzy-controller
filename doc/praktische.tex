%http://www.daniel-brettschneider.de/allgemein/latex-vorlage-fur-hausarbeiten-oder-abschlussarbeiten
\documentclass[12pt,a4paper,bibliography=totocnumbered,listof=totocnumbered, abstracton]{scrartcl}

\usepackage[autostyle=true,german=quotes]{csquotes}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{geometry}
\usepackage{setspace}
\usepackage[right]{eurosym}
\usepackage[printonlyused]{acronym}
\usepackage{subfig}
\usepackage{floatflt}
\usepackage[usenames,dvipsnames]{color}
\usepackage{colortbl}
\usepackage{paralist}
\usepackage{array}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage[right]{eurosym}
\usepackage[subfigure,titles]{tocloft}
\usepackage[pdfpagelabels=true]{hyperref}
\usepackage[ngerman]{babel}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{csquotes}
\usepackage{siunitx}
\newtheoremstyle{Umgebung}	% name
{20pt}	% Space above, empty = `usual value'
{20pt} % Space below
{} % Body font
{} % Indent amount (empty = no indent, \parindent = para indent)
{\bfseries} % Thm head font
{} % Punctuation after thm head
{\newline} % Space after thm head: \newline = linebreak
{} % Thm head spec

\def\code#1{\texttt{#1}}
% "define" Scala
\lstdefinelanguage{scala}{
	morekeywords={abstract,case,catch,class,def,%
		do,else,extends,false,final,finally,%
		for,if,implicit,import,match,mixin,%
		new,null,object,override,package,%
		private,protected,requires,return,sealed,%
		super,this,throw,trait,true,try,%
		type,val,var,while,with,yield},
	otherkeywords={=>,<-,<\%,<:,>:,\#,@},
	sensitive=true,
	morecomment=[l]{//},
	morecomment=[n]{/*}{*/},
	morestring=[b]",
	morestring=[b]',
	morestring=[b]"""
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{myScalastyle}{
	frame=tb,
	language=scala,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=left,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	frame=single,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=2,
}


\theoremstyle{Umgebung}

\lstset{basicstyle=\footnotesize, captionpos=b, breaklines=true, showstringspaces=false, tabsize=2, frame=lines, numbers=left, numberstyle=\tiny, xleftmargin=2em, framexleftmargin=2em}
\makeatletter
\def\l@lstlisting#1#2{\@dottedtocline{1}{0em}{1em}{\hspace{1,5em} Lst. #1}{#2}}
\makeatother
\geometry{a4paper, top=27mm, left=30mm, right=20mm, bottom=35mm, headsep=10mm, footskip=12mm}
\hypersetup{unicode=false, pdftoolbar=true, pdfmenubar=true, pdffitwindow=false, pdfstartview={FitH},
	pdftitle={Ausarbeitung Projektvortrag Fuzzy-Regelung},
	pdfauthor={Joel Bartelheimer, Nico Müller},
	pdfsubject={Ausarbeitung Fuzzy-Reglung},
	pdfcreator={\LaTeX\ with package \flqq hyperref\frqq},
	pdfproducer={pdfTeX \the\pdftexversion.\pdftexrevision},
	pdfkeywords={Ausarbeitung Projektvortrag Fuzzy-Regelung},
	pdfnewwindow=true,
	colorlinks=true,linkcolor=black,citecolor=black,filecolor=magenta,urlcolor=black}
\pdfinfo{/CreationDate (D:20110620133321)}
\begin{document}
\titlespacing{\section}{0pt}{12pt plus 4pt minus 2pt}{-6pt plus 2pt minus 2pt}
% Kopf- und Fusszeile
\renewcommand{\sectionmark}[1]{\markright{#1}}
\renewcommand{\leftmark}{\rightmark}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\thesection\space\contentsname}
\lfoot{Ausarbeitung Projektvortrag Fuzzy-Regelung}
\cfoot{}
\rfoot{ Seite \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
% Vorspann
\renewcommand{\thesection}{\Roman{section}}
\renewcommand{\theHsection}{\Roman{section}}
\pagenumbering{roman}
% ----------------------------------------------------------------------------------------------------------
% Titelseite
% ----------------------------------------------------------------------------------------------------------
\thispagestyle{empty}
\begin{center}
	\includegraphics[width=5cm]{img/thm2.png}\\
	\vspace*{2cm}
	\Large
	\textbf{Fachbereich}\\
	\textbf{Mathematik, Naturwissenschaften und Informatik }\\
	\vspace*{2cm}
			\Huge
	\textbf{Ausarbeitung Projektvortrag Fuzzy-Regelung}\\
	\vspace*{1.5cm}
		\small
		\textbf{Im Rahmen der Veranstaltung:}\\
		\Large
	\textbf{Praktikum Künstliche Intelligenz(CS5330)}\\
	\vspace*{2cm}
	

	\normalsize
	\newcolumntype{x}[1]{>{\raggedleft\arraybackslash\hspace{0pt}}p{#1}}
	\begin{tabular}{x{7.5cm}x{7.5cm}}
		\rule{0mm}{5ex}\textbf{Autoren:} 
		\newline 
		\newline Joel Bartelheimer
		\newline joel.bartelheimer@mni.thm.de
		\newline 
		\newline Nico Müller
		\newline nico.mueller@mni.thm.de
		\newline
		& 
		\rule{0mm}{5ex}\textbf{Eingereicht bei:} 
		\newline
		\newline  Prof. Dr. Wolfgang Henrich
		\newline
		\newline\rule{0mm}{5ex}\textbf{Abgabedatum:} 
		\newline 14.02.2017
		\newline
	\end{tabular} 
\end{center}
\pagebreak

% ----------------------------------------------------------------------------------------------------------
% Verzeichnisse
% ----------------------------------------------------------------------------------------------------------
% TODO Typ vor Nummer
\renewcommand{\cfttabpresnum}{Tab. }
\renewcommand{\cftfigpresnum}{Abb. }
\settowidth{\cfttabnumwidth}{Abb. 10\quad}
\settowidth{\cftfignumwidth}{Abb. 10\quad}
\titlespacing{\section}{0pt}{12pt plus 4pt minus 2pt}{2pt plus 2pt minus 2pt}
\singlespacing
\rhead{INHALTSVERZEICHNIS}
\renewcommand{\contentsname}{II Inhaltsverzeichnis}
\phantomsection
\addcontentsline{toc}{section}{\texorpdfstring{II \hspace{0.35em}Inhaltsverzeichnis}{Inhaltsverzeichnis}}
\addtocounter{section}{1}
\tableofcontents
\pagebreak
\rhead{VERZEICHNISSE}


% ----------------------------------------------------------------------------------------------------------
% Inhalt
% ----------------------------------------------------------------------------------------------------------
% Abstände Überschrift
\titlespacing{\section}{0pt}{12pt plus 4pt minus 2pt}{-6pt plus 2pt minus 2pt}
\titlespacing{\subsection}{0pt}{12pt plus 4pt minus 2pt}{-6pt plus 2pt minus 2pt}
\titlespacing{\subsubsection}{0pt}{12pt plus 4pt minus 2pt}{-6pt plus 2pt minus 2pt}
% Kopfzeile
\renewcommand{\sectionmark}[1]{\markright{#1}}
\renewcommand{\subsectionmark}[1]{}
\renewcommand{\subsubsectionmark}[1]{}
\lhead{Kapitel \thesection}
\rhead{\rightmark}
\onehalfspacing
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\theHsection}{\arabic{section}}
\setcounter{section}{0}
\pagenumbering{arabic}
\setcounter{page}{1}

\newtheorem{bsp}{Beispiel}
\newtheorem{defnt}{Definition}

% ----------------------------------------------------------------------------------------------------------
% Einleitung
% ----------------------------------------------------------------------------------------------------------
\begin{abstract} 
	Die vorliegende Hausarbeit gibt einen Einstieg in die theoretische Fuzzy-Logik und behandelt dabei Fuzzy-Mengen, Fuzzy-Relation sowie Fuzzy-Operationen. Dem Leser soll bewusst gemacht werden worin sich die scharfe Mengenlehre von der der Fuzzy-Mengenlehre unterscheidet. An anschaulichen Beispielen wird erklärt was Linguistische Terme sind und wie diese repräsentiert werden können. Eigentliches Ziel ist die Untersuchung des Einsatzgebiets der Fuzzy-Regler, welches ein Teilgebiet der Fuzzy-Logik darstellt. Hier werden die Komponenten wie z.B. die Wissensbasis, das Fuzzyfizierungs- und Defuzzyfizierungs-Interface sowie die Entscheidungslogik vorgestellt. Da zur Zeit zwei Varianten (Mamdani sowie Takagi/Sugeno)  der Fuzzy-Regler verbreitet sind, werden diese beiden nacheinander vorgestellt und deren Vorteile aufgezeigt. Zuletzt werden die üblichen Defuzzifizierungsmethoden erklärt und an einem Beispiel veranschaulicht.
\end{abstract} 
\newpage

\section{Problemstellung}

Die gestellte Aufgabe zur praktischen Ausarbeitung kommt aus dem Themengebiet des autonomen Fahrens. Es soll ein Fuzzy Regler eingesetzt werden um ein Fahrzeug so zu steuern, dass es einem anderen, durch den Menschen gesteuerten, Fahrzeug folgt.  Hierbei ist zu beachten, dass das hier bei nur die Geschwindigkeit bzw. Bewegung in einer Achse kontrolliert wird. Das bedeutet, dass nur das Gas- sowie das Bremspedal jedoch nicht das Lenkrad geregelt werden muss. Außerdem gehen wir davon aus, dass es sich bei dem gesteuerten Fahrzeug um ein Fahrzeug mit Automatikgetriebe handelt und somit das Kuppeln sowie das Schalten der Gänge ebenfalls irrelevant ist. 

Bei der Implementierung sollte darauf geachtet werden, dass beide Fahrzeuge, so weit wir möglich, den physikalischen Gesetzen unterliegen. Dies bedeutet, dass z.B. die Fahrwiderstände wie Luftwiderstand, Rollwiderstand usw. beachtet werden müssen. Ebenfalls sollten beide Fahrzeuge durch eine physikalische Spezifikation, wie z.B. das Gewicht, definiert werden. Beide Fahrzeuge sollten hierbei der gleichen physikalische Spezifikation unterliegen, um keines der beiden Fahrzeuge einen Vorteil zu bieten.

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{img/practical/problem}
	\caption{Problemstellung}
	\label{fig:problem}
\end{figure}

\section{Implementierung}

Dieses Kapitel dient 

\subsection{Funktionale Programmierung}

Als funktionale Programmierung bezeichnet man ein Programmierparadigma in dem alles Programme lediglich aus Funktionen bestehen. Hierbei können neue Funktionen aus bereits bestehenden Funktionen zusammengesetzt werden. Ebenfalls werden Funktionen in der funktionalen Programmierung als Wert angesehen. Dies erlaubt es Funktionen als Parameter oder Rückgabe zu verwenden, dies nennt man \enquote{Funktion höhrer Ordnung}. In sogenannten \enquote{reinen} funktionalen Programmiersprachen gibt es keine Variablen womit Seiteneffekte vollkommen ausgeschlossen werden. Für die Implementierung wird die Sprache Scala\footnote{https://www.scala-lang.org/} verwendet. Scala ist eine JVM-Sprache die funktionale Programmierung und Objektorientierte Programmierung verbindet. Wir haben diese Sprache gewählt, da wir einerseits unsere Kenntnisse in der Sprache durch das Projekt erweitern wollten aber auch anderseits der Meinung waren, dass sich eine Fuzzy Regelung einfacher mithilfe von Funktionen höherer Ordnung ausdrücken lassen.

\subsection{Modell des Fahrzeugs}

Die Modelle der beiden Fahrzeuge werden in der Klasse \enquote{Car} realisiert (siehe Abbildung \ref{fig:car}). Jedes erstellte Fahrzeug hat ein vorgegebenes Gewicht in $kg$, ein Strömungswiderstandskoeffizient (dimensionslos) sowie eine gegebene Fläche der projizierte Stirnfläche in $m^2$. Ebenfalls wird eine maximale Brems bzw. Antriebskraft festgelegt. Wir haben für unser Modell diese Werte von realen Fahrzeugen übernommen und uns auf die Werte aus Tabelle \ref{table:car} festgelegt.

Zusätzlich wird für jedes Object des Typs \enquote{Car} die aktuelle Position relativ zum Null Punkt in $m$, die aktuelle Geschwindigkeit in $m/s$ sowie  die aktuelle Beschleunigung in $m/s^2$ dokumentiert. Der Nutzer der Klasse hat die Möglichkeit die Brems bzw. Antriebskraft in $N$ für das Auto über ein Interface zu setzen.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/car-diagram}
	\caption{UML der Klasse Auto und deren Nachbarklassen.}
	\label{fig:car}
\end{figure}

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[]
	\centering
	\caption{Phssikalische Spezifikation der Autos}
	\label{table:car}
	\begin{tabular}{@{}llll@{}}
		\toprule
		Eigenschaft                     & Wert & Einheit & Bezeichner           \\ \midrule
		Gewicht                         & 1540 & $kG$    & $m_{Fzg}$            \\
		Zuladung                        & 0    & $kG$    & $m_{Zu}$             \\
		Strömungswiderstandskoeffizient & 0.67 & -       & $cw$                 \\
		Projizierte Stirnfläche         & 1.86 & $m^2$   & $A$                  \\
		Maximale Bremskraft             & 8000 & $N$     & $\overline{F}_{max}$ \\
		Maximale Antriebskraft          & 3000 & $N$     & $ {F}_{max} $        \\
		Massefaktor                     & 1    & -       & $ {e}_{i} $          \\ \bottomrule
	\end{tabular}
\end{table}

\subsubsection{Bestimmung der Beschleunigung}

Um die gesetzte Brems bzw. Antriebskraft, unter Berücksichtigung der physikalischen Gesetze, in eine Beschleunigung umzurechnen, betrachten wir zunächst die Fahrwiderstände die ein Fahrzeug überwinden muss. Als Fahrwiderstand $F_{FW}$ wird die Summe der Widerstände bezeichnet, die ein Fahrzeug mit Hilfe einer Antriebskraft überwinden muss, um das Fahrzeug zu bewegen. Dazu gehört der Luftwiderstand $F_{Luft}$, der Rollwiderstand $F_{Roll}$, der Steigungswiderstand $F_{Steig}$ sowie der Beschleunigungswiderstand $F_{B}$.

\paragraph{Luftwiderstand}

Der Luftwiderstand ist maßgeblich für die Höchstgeschwindigkeit eines Fahrzeugs. Er hängt von der aerodynamischen Form des Fahrzeuges ab und steigt mit der Geschwindigkeit ins Quadrat. Außerdem spielt die momentane Luftdichte $p_{Luft}$ in $kg/m^3$ eine Rolle für den Luftwiderstand. Diese ist abhängig von der Höhe in der Atmosphäre sowie der Temperatur der Atmosphäre.  Wir haben für diese Umgebungsvariable einen Wert von $1,2$ gewählt, dies Entspricht der Luftdichte bei einer Temperatur von $20^\circ\text{C}$ auf Höhe des Meeresspiegels.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/Luftwiderstand}
	\caption{Prinzipskizze zum Luftwiderstand an Fahrzeugen (Simon Herzog (https://commons.wikimedia.org/wiki/File:Luftwiderstand.png), https://creativecommons.org/licenses/by-sa/4.0/legalcode)}
	\label{fig:luftwiderstand}
\end{figure}

\begin{equation}
F_{Luft} = cw \cdot A \cdot \frac{p_{Luft} \cdot v_{Fzg}^2}{2}
\end{equation}

\paragraph{Rollwiderstand}

Der Rollwiderstand beschreibt die nötige Arbeit um einen Reifen auf einer Kontaktfläche zu rollen. Durch die Fahrzeugmaße und das elastische Material des Reifens sowie dem Boden werden diese zusammengedrückt und bilden keine optimale Kreisform mehr. Diese Eigenschaft wird durch den Rollwiderstandskoeffizient $f_{Roll}$ abstrahiert. Wir haben für diese Umgebungsvariable einen Wert von $0,01$ gewählt was einem Autoreifen auf einem Asphaltboden entspricht. In die Formel geht außerdem die Erdbeschleunigung $g$ sowie der Steigungswinkel  $a$ eine Rolle. Wenn der Steigungswinkel steigt oder sinkt, also $ |a|  \gg 0$, konvergiert der Rollwiderstand gegen $0$. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/Rollwiderstand}
	\caption{Prinzipskizze zum Rollwiderstand an Fahrzeugen (Simon Herzog (https://commons.wikimedia.org/wiki/File:Rollwiderstand.png), https://creativecommons.org/licenses/by-sa/4.0/legalcode)}
	\label{fig:Rollwiderstand}
\end{figure}

\begin{equation}
F_{Roll} = f_{Roll} \cdot (m_{Fzg} + m_{Zu}) \cdot g \cdot cos(a)
\end{equation}


\paragraph{Steigungswiderstand}

Der Steigungswiderstand beschreibt die nötige Kraft die benötigt wird um die Maße des Fahrzeugs über die Steigung zu bewegen. Falls die Steigung negativ ist, wird der Steigungswiderstand negativ und beeinflusst somit das Fahrzeug positiv. Der Steigungswiderstand spielt in unserer Aufgabenstellung z.Z. keine Rolle, da von einer ebenen Strecke ausgegangen werden soll. Dennoch wurde dieser im Sinne der Vollständigkeit implementiert und hier aufgeführt.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/Steigungswiderstand}
	\caption{Prinzipskizze zum Steigungswiderstand an Fahrzeugen (Simon Herzog (https://commons.wikimedia.org/wiki/File:Steigungswiderstand.png), https://creativecommons.org/licenses/by-sa/4.0/legalcode)}
	\label{fig:Steigungswiderstand}
\end{figure}

\begin{equation}
F_{Steig} = (m_{Fzg} + m_{Zu}) \cdot g \cdot sin(a)
\end{equation}

\paragraph{Beschleunigungswiderstand}

Der Beschleunigungswiderstand beschreibt die nötige Kraft die benötigt wird um die Beschleunigung eines Fahrzeugs zu ändern. Dieser Widerstand entsteht durch die Trägheit des Fahrzeugs. Der Massefaktor $e_i$ (>=1) fasst den translatorischer Anteil, also Maße die sich in Fahrtrichtung bewegt sowie den rotatorischer Anteil, also alle rotierende Teile im Antriebsstrang (Motor, Kurbelwelle, Kupplung, Räder) zusammen. Der Massefaktor ist somit auch stark abhängig vom gewählten Gang des Fahrzeugs. In unserem Modell ist der Massefaktor auf 1 gesetzt.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/Beschleunigungswiderstand}
	\caption{Prinzipskizze zum Beschleunigungswiderstand an Fahrzeugen (Simon Herzog (https://commons.wikimedia.org/wiki/File:Beschleunigungswiderstand.png), https://creativecommons.org/licenses/by-sa/4.0/legalcode)}
	\label{fig:Beschleunigungswiderstand}
\end{figure}

\begin{equation}
 F_{B}=(e_{i}\cdot m_{Fzg} +m_{Zu}) \cdot a
\end{equation}

\begin{equation}
F_{FW} = F_{Luft} + F_{Roll} + F_{Steig} + F_{B}
\end{equation}

Um nun die tatsächliche Kraft zu erhalten müssen die Fahrwiderstände von der Antriebskraft subtrahiert werden. Dieser Kraft definiert als $kg * m/s^2$ kann nun in die aktuelle Beschleunigung umgerechnet werden.

\begin{equation}
a = \frac{F - F_{FW}}{m_{Fzg} + m_{Zu}}
\end{equation}

\subsubsection{Bestimmung der Position}

Die Position eines jeden Fahrzeugs lässt sich über die Integration der Beschleunigung errechnen. Durch Ableitung der Position (siehe Gl. 1) ergibt sich die Geschwindigkeit (siehe Gl. 2). Durch ein weiteres Ableiten erhält man die Beschleunigung (siehe Gl. 3). Da unser System zunächst nur die Beschleunigung bereitsteht, lässt sich durch die Integration auf die Geschwindigkeit (siehe Gl. 4) sowie in einem weiteren Schritt auf die Position schließen (siehe Gl. 5).

\begin{equation}
	s(t) = \text{Position zur Zeit t}
\end{equation}

\begin{equation}
	\dot{s}(t) = v(t) = \text{Geschwindigkeit zur Zeit t}
\end{equation}

\begin{equation}
	\ddot{s}(t) = \dot{v}(t) = a(t) = \text{Beschleinung zur Zeit t}
\end{equation}

\begin{equation}
	\begin{aligned}
		\dot{v}(t)                 & = a(t)                        \\
		\int_{0}^{t} \dot{v}(t) dt & = \int_{0}^{t} a(t) dt        \\
		v(t)\Big|_0^t              & = a(t) \cdot t \Big|_0^t      \\
		v(t) - v(0)                & = a(t) \cdot t - a(0) \cdot 0 \\
		v(t)                       & = a(t) \cdot t + v(0)
	\end{aligned}
\end{equation}

\begin{equation}
\begin{aligned}
	\dot{s}(t)                 & = v(t)                                              \\
	\int_{0}^{t} \dot{s}(t) dt & = \int_{0}^{t} v(t) dt                              \\
	\int_{0}^{t} \dot{s}(t) dt & = \int_{0}^{t} a(t) \cdot t + v(0) dt               \\
	s(t)\Big|_0^t              & = 0,5 \cdot a(t) \cdot t^2 + v(t) \cdot t \Big|_0^t \\
	s(t) - s(0)                & = 0,5 \cdot a(t) \cdot t^2 + v(t) \cdot t           \\
	s(t)                       & = 0,5 \cdot a(t) \cdot t^2 + v(t) \cdot t + s(0)
\end{aligned}
\end{equation}

\paragraph{Numerische Integration}

Die numerische Integration in unserem System wird durch eine kontinuierliche, schrittweise Integration umgesetzt. Hierfür muss in zyklischen Abständen die Beschleunigung gemessen werden und dann die draus resultierende Geschwindigkeit und Position berechnet und aktualisiert werden. Wichtig ist hierbei, dass die Zeit zwischen diesen zyklischen Aufrufen festgehalten wird.

Im Code Beispiel (siehe Listing \ref{lst:integration}) wird in der Funktion \code{tick()} die numerische Integration implementiert. Die Variable \code{past} enthält einen Zeitstempel der gespeichert wurde, als die Funktion das letzte mal aufgerufen wurde. Wichtig ist hierbei, dass der Sichtbarkeitsbereich der Variablen außerhalb der Funktion liegt. So kann bei jedem Aufruf die vergangene Zeit zwischen dem aktuellen und vorherigen Aufruf bestimmt werden. Nach Abschluss der Berechnung wird Zeitstempel überschrieben.

\begin{lstlisting}[style=myScalastyle, caption=Numerische Integration, label=lst:integration]]
	var acceleration: Double = 0
	var speed: Double = 0
	var position: Double = 0
	var past: Long = System.currentTimeMillis()

	def tick(): Unit = {
		// Bestimmen der aktuellen Zeit
		val now = System.currentTimeMillis()
		// Berechnung der vergangenen Zeit in Sekunden
		val t: Double = (now - past) / 1000.0 
		
		// Erste Schritt der Integration
		acceleration = (engineForce - antiForce) / mass
		// Zweiter Schritt der Integration
		speed += (acceleration * t)
		// Dritter Schritt der Integration
		position += ((0.5 * acceleration * t * t) + speed * t)

		// Speichern der Aufrufszeit
		past = now;
	}
\end{lstlisting}

\subsection{Modell der Wissensbasis}

Die Wissensbasis besteht aus der Regelbasis und der Datenbasis. Alle Wertebereiche für die Eingangsgrößen und Stellgrößen sowie die dazugehörigen linguistischen Termen und dazu assoziierten Fuzzy-Mengen gehören zu der Datenbasis. Die Regelbasis bestehtaus den linguistischen Kontrollregeln. Die Wissensbasis soll durch den Benutzer zur Laufzeit des konfigurierbar sein. Aus diesem Grund wurden alle nötigen Parameter in ein Konfigurationsobjekt gebettet das zur jeder Zeit vom Fuzzy Regler geladen werden kann. Um das Verständnis zu verbessern werden nun die einzelnen Komponenten der Wissensbasis und deren dazugehörigen Modellierungen vorgestellt.

\paragraph{Eingangs- Ausgangsgrößen}

Für jede messbare Eingangsgröße und jede Ausgangsgröße muss ein Wertebereich und ein Bezeichner festgelegt werden, sodass andere Programmteile diese wieder erkennen können. Diese Größen nennen wir \code{FuzzyValueConnector}.

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{img/practical/valueconnector}
	\caption{Modellierung der Wissensbasis}
	\label{fig:valueconnector}
\end{figure}

\paragraph{Fuzzy-Menge und Linguistischer Term}

Da ein linguistischer Term immer nur einer Fuzzy-Menge zugeordnet sein sollte, wurden diese Elemente in unserem Model in der Klasse \code{FuzzyTerm} implementiert. Die eigentliche Zugehörigkeitsfunktion wird durch die Funktion höherer Ordnung \code{(Double => FuzzyBool)} ausgedrückt. Wobei \code{FuzzyBool} nur ein Fließkommazahl in den Grenzen $\left[0,1\right]$ ist.

\paragraph{Fuzzy-Regeln}

Die Regelbasis in Form von linguistischen "Wenn - Dann - Regeln" wird durch die Klasse \code{FuzzyRule} modelliert. Jede Regel wird durch ihren Namen identifiziert und enthält eine List von \code{FuzzyTerm} die die Eingangsgrößen darstellen. Die Verknüpfung dieser Eingangsgrößen wird durch eine Liste von Operatoren modelliert. Außerdem wird eine Ausgangsgröße, ebenfalls in Form eines \code{FuzzyTerm} festgelegt.

\paragraph{Defuzzyfizierungs-Methoden}

Die Aufgabe der Defuzzyfizierungs-Methoden ist es aus der Ausgangsfuzzymenge einen Stellwert auszuwählen. In unserer Modellierung arbeitet die Defuzzyfizierungs-Methoden mit einer Liste aller im Wertebereich enthaltenen Werte auf die die kombinierten Zugehörigkeitsfunktion aller Regeln bereits angewendet wurden. Sie liefert dann einen Stellwert in diesem Wertebereich zurück. Die Defuzzyfizierungs-Methoden wird durch die Funktion höherer Ordnung \code{List[Double] => Int)} beschrieben und durch einen Namen identifiziert und in der Klasse \code{FuzzyDefuzzyficationFunc} zusammengefasst.



\subsection{Konfiguration}

Mögliche Konfigurationen sind:

\begin{itemize}
	\item Partitionierung der Eingangsvariablen
	\item Partitionierung der Ausgangsvariablen
	\item Erstellung der linguistischen Regeln
	\item Wahl der Defuzzifizierungsmethode
\end{itemize}
Es wurden folgende Voreinstellungen für die Regelung gemacht:

\paragraph{Wertebreiche}
Distanz: 0-500 Meter \\
Geschwindigkeit: 0-250 km/h \\
Beschleunigung: -8000-4000 N \\

\paragraph{Partitionierung Distanz}
$\newline$
isVeryClose = $-\infty, 100, 200$ \\
isClose = $100, 200, 300$ \\
isNormal = $250, 300, 350$ \\
isFar = $300, 300, 500$ \\
isVeryFar = $400, 500, \infty$ \\

\paragraph{Partitionierung Geschwindigkeit}
$\newline$
isSlow = $-\infty, 15, 30$ \\
isFast = $15, 50, 100$ \\
isExtreme = $50, 150, 350$ \\

\paragraph{Partitionierung Beschleunigung}
$\newline$
fullBrake = $-\infty, -8000, -7000$ \\
medBrake = $-8000, -5000, -2000$ \\
brake = $-5000, -2000, 0$ \\
roll = $-500, 0, 500$ \\
speed = $0, 1000, 2000$ \\
medSpeed = $1000, 2000, 3000$ \\
fullSpeed = $2000, 3000, \infty$ \\

\paragraph{Regeln}

\begin{lstlisting}
IF Distance = isVeryFar AND Speed = isSlow THEN Force = fullSpeed
IF Distance = isVeryFar AND Speed = isFast THEN Force = fullSpeed
IF Distance = isVeryFar AND Speed = isExtreme THEN Force = fullSpeed
IF Distance = isFar AND Speed = isSlow THEN Force = fullSpeed
IF Distance = isFar AND Speed = isFast THEN Force = medSpeed
IF Distance = isFar AND Speed = isExtreme THEN Force = speed
IF Distance = isNormal AND Speed = isSlow THEN Force = roll
IF Distance = isNormal AND Speed = isFast THEN Force = roll
IF Distance = isNormal AND Speed = isExtreme THEN Force = roll
IF Distance = isClose AND Speed = isSlow THEN Force = brake
IF Distance = isClose AND Speed = isFast THEN Force = medBrake
IF Distance = isClose AND Speed = isExtreme THEN Force = fullBrake
IF Distance = isVeryClose AND Speed = isSlow THEN Force = fullBrake
IF Distance = isVeryClose AND Speed = isFast THEN Force = fullBrake
IF Distance = isVeryClose AND Speed = isExtreme THEN Force = fullBrake

\end{lstlisting}

\subsection{Fuzzy Controller}

\subsection{Grafische Oberfläche}


\section{Fazit}

\subsection{Probleme}

Leider ist dem Team zu spät aufgefallen, dass es sinnvoll gewesen wäre eine Ableitung des Abstands in die Regelung mit einzubringen. Die gesamte Regelung erscheint nun ein wenig Träge.

% ----------------------------------------------------------------------------------------------------------

\end{document}